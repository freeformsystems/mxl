#!/usr/bin/env node

var path = require('path')
  , fs = require('fs')
  , argparse = require('cli-argparse')
  , argv = argparse()
  , verbose = argv.flags.v
  , revert = require('ttycolor').defaults()
  , pkg = 'package.json'
  , rcname = 'mxlrc.json'
  , rc = '.' + rcname
  , profile = ':'
  , aliased = false
  , usealias = process.env.mxl_no_autoalias === undefined
  , target = argv.unparsed[0]
  , rcfile = path.join(process.env.HOME, rc)
  , env = require('cli-env').env
  , config
  , husk = require('husk')
  .exec().fs()
  .plugin([
    require('husk-parse'),
    require('husk-transform')
  ]);

// generic error handler
process.on('uncaughtException', function(e) {
  console.error(e.stack);
  process.exit(1);
});

// enable tmux exec method
husk.command('tmux');

function rcread() {
  var dir = target || process.cwd();
  // got profile reference
  if(dir.indexOf(profile) === 0) {
    dir = process.cwd(); 
  }
  var input = dir;
  try {
    config = '' + fs.readFileSync(rcfile);
  }catch(e){}

  if(config) {
    try {
      config = JSON.parse(config);
      config.alias = config.alias || {};
    }catch(e){}
  }

  // lookup alias in config
  if(config && target && config.alias[target]
    && fs.existsSync(config.alias[target])) {
    dir = config.alias[target];
    if(verbose) {
      console.log('use alias %s=%s', target, dir);
    }
    aliased = true;
  }

  if(path.basename(dir) !== pkg) {
    input = path.join(dir, pkg);
  }
  return input;
}

function rcwrite(alias, dir) {
  if(!usealias || aliased || (!aliased && config && config.alias[alias])) {
    return false; 
  }
  config = config || {alias: {}};
  config.alias[alias] = dir;
  fs.writeFileSync(rcfile, JSON.stringify(config, undefined, 2));
  if(verbose) {
    console.log('aliased %s=%s', alias, dir);
  }
}

function run(file) {
  var dir = path.dirname(file)
    , hasrc = fs.existsSync(path.join(dir, rc));
  if(hasrc) {
    file = path.join(dir, rc); 
  }
  if(verbose) {
    console.log('file %s', file);
  }
  husk(file)
    .read()
    .parse({field: 'body'}, function(){return this.body})
    .transform(function() {
      // allow environment variable replacement
      var tmux = hasrc ? this.body : this.body.tmux || {};
      env(tmux)
      return this;
    })
    .async(function(cb) {
      var tmux = hasrc ? this.body : this.body.tmux || {};
      var run = tmux.run || [];
      var arg = target || argv.unparsed[1] || '';
      var pf = arg.indexOf(profile) === 0 ? arg.substr(1) : null;
      if(typeof run === 'string' && tmux.profiles && tmux.profiles[run]) {
        run = tmux.profiles[run];
      }
      if(pf && tmux.profiles && tmux.profiles[pf]) {
        if(verbose) {
          console.log('profile %s (%s)', pf, file);
        }
        run = tmux.profiles[pf];
      // run config level profile
      }else if(pf && config.profiles && config.profiles[pf]) {
        run = config.profiles[pf];
      }
      if(!Array.isArray(run)) {
        return cb(); 
      }
      var h = husk();
      run.forEach(function(cmd) {
        var args = Array.isArray(cmd) ? cmd : (cmd || '').split(/\s+/);
        if(verbose) {
          console.log('tmux %s', cmd);
        }
        h = h.tmux.apply(h, args);
      })
      h.run(cb);
    })
    .run(function() {
      rcwrite(path.basename(dir), dir);
    });
}

var src = rcread();
process.env.mxl_project = path.dirname(src);
run(src);
